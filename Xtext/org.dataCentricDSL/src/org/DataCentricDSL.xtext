grammar org.DataCentricDSL with org.eclipse.xtext.xbase.Xbase

generate dataCentricDSL "http://www.DataCentricDSL.org"

DataCentricDSL:
	(elements += FunctionDecl)*
	(elements += Statement)*
;

Statement:
	(SimpleStatement | 
	 CompoundStatement)
;

SimpleStatement:
	(VariableDecl | 
	 QueryFunction | 
	 PrintFunction | 
	 MultiAssign | 
	 PostfixOperation | 
	 FunctionCall) Semicolon
;

VariableDecl:
	(isGlobal?=Global)? name=IDENTIFIER OpAssignment variableValue=VariableParam
;

VariableParam returns VariableDecl:
	{VariableParam} 
	(variableExpressionParam=Expression | 
	 variableQueryParam=QueryFunction |
	 variableBolleanValue=BooleanValue)
;

QueryFunction:
	Query QueryParam
;

QueryParam returns Query: 
	 queryParam=Expression
;

PrintFunction:
	(Print | Println) PrintParam
;

PrintParam returns Print:
	printParam=(QueryFunction | 
	 Expression)
;

FunctionCall:
	name=IDENTIFIER OpeningBracket  
		(arguments+=(Expression) 
		(Comma arguments+=(Expression))*)?
	 ClosingBracket
;

VariableCall:
	{VariableCall} variableCall=IDENTIFIER
;

Expression:
	Addition
;

Addition returns Expression:
	(Substraction | StringLiteral) ({Addition.left=current} OpAddition right=(Substraction | StringLiteral))*
;

Substraction returns Expression:
	Multiplication ({Substraction.left=current} OpSubstraction right=Multiplication)*
;

Multiplication returns Expression:
	Division ({Multiplication.left=current} OpMultiplication right=Division)*
;
 
Division returns Expression:
	Mod ({Division.left=current} OpDivision right=Mod)*
;

Mod returns Expression:
	Primary ({Mod.left=current} OpMod right=Primary)*
;

Primary returns Expression:
	(NumberLiteral | 
	 VariableCall | 
	 FunctionCall |
	 OpeningBracket Addition ClosingBracket)
;

CompoundStatement:
	IfStatement |
//	not supported in Antlr grammar, for now
//	SwitchStatement |
	WhileStatement |
	ForStatement
;

FunctionDecl:
	Func name=IDENTIFIER OpeningBracket
		(arguments+=IDENTIFIER (Comma arguments+=IDENTIFIER)*)?
		ClosingBracket OpeningCurlyBracket
		(statements+=Statement)*
	ClosingCurlyBracket
;

IfStatement:
	{IfStatement}
	If OpeningBracket condition += StatementCondition ClosingBracket OpeningCurlyBracket
		(statements+=Statement)*
	ClosingCurlyBracket
	( ElseIf OpeningBracket condition+=StatementCondition ClosingBracket OpeningCurlyBracket
		(statements+=Statement)*
	ClosingCurlyBracket
	)*
	( Else OpeningCurlyBracket 
		(statements+=Statement)*
	ClosingCurlyBracket
	)?
;

/*
SwitchStatement:
	{SwitchStatement}
	'switch' OpeningBracket name=VariableCall ClosingBracket OpeningCurlyBracket
		('case' cases+=STRING ':'
			(statements+=Statement)*
		)*
		('default' ':'
			(statements+=Statement)*
		)?
	ClosingCurlyBracket
;*/

WhileStatement:
	{WhileStatement}
	While OpeningBracket whileCondition=StatementCondition ClosingBracket OpeningCurlyBracket 
		(statements+=Statement)* 
	ClosingCurlyBracket
;

ForStatement:
	{ForStatement}
	For OpeningBracket forVar=VariableDecl Semicolon 
		forCondition=StatementCondition Semicolon
		operation=(PostfixOperation | ForMultiAssign | VariableDecl) 
		ClosingBracket OpeningCurlyBracket 
			(statements+=Statement)* 
	ClosingCurlyBracket
;

StatementCondition:
	statementCondition+=Condition ((OpAnd | OpOr) statementCondition+=Condition)* 
;

Condition:
	 expressions+=ConditionElement (op+=OpCompare expressions+=ConditionElement)?
;

ConditionElement:
	(Expression |
	 BooleanValue)
;

ForMultiAssign:
	left=VariableCall op=MultiAssignOperator right=INT
;

MultiAssign:
	left=VariableCall op=MultiAssignOperator right=MultiAssignRightOperand 
;

MultiAssignRightOperand:
	(Expression | 
	 QueryFunction)
;

PostfixOperation:
	{PostfixOperation} call=VariableCall op=PostfixOperationOperator
;

StringLiteral:
	value=STRING
;

NumberLiteral:
	value=NUMBER_LITERAL
;

BooleanValue:
	value=('true' | 
	'false')
;

MultiAssignOperator:
	('+=' | 
	'-=' | 
	'*=' | 
	'/=' | 
	'%=')
;

PostfixOperationOperator:
	('--' |
	'++')
;

OpAddition:
	'+'
;

OpSubstraction:
	'-'
;

OpMultiplication:
	'*'
;

OpDivision:
	'/'
;

OpMod:
	'%'
;

OpAssignment:
	'='
;

OpAnd:
	'&&'
;

OpOr:
	'||'
;

OpCompare:
	('>' |
	'<' |
	'==' |
	'<=' |
	'>=' |
	'!=')
;

Semicolon:
	';'
;

OpeningBracket:
	'('
;

ClosingBracket:
	')'
;

Comma:
	','
;

OpeningCurlyBracket:
	'{'
;

ClosingCurlyBracket:
	'}'
;

Global:
	'global'
;

Query:
	'query'
;

Print:
	'print'
;

Println:
	'println'
;

Func:
	'func'
;

If:
	'if'
;

ElseIf:
	Else If
;

Else:
	'else'
;

While:
	'while'
;

For:
	'for'
;

terminal NUMBER_LITERAL:
	'0' | (('1'..'9') ('0'..'9')*) ('.' ('0'..'9')*)?
;

terminal IDENTIFIER:
	('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*
;
