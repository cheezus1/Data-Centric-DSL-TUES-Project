grammar org.DataCentricDSL with org.eclipse.xtext.xbase.Xbase

generate dataCentricDSL "http://www.DataCentricDSL.org"

DataCentricDSL:
	(elements += (Statement | FunctionDecl))*
;

Statement:
	(SimpleStatement | 
	 CompoundStatement)
;

SimpleStatement:
	(VariableDecl | 
	 Query | 
	 Print | 
	 MultiAssign | 
	 PostfixOperation | 
	 FunctionCall) ';'
;

VariableDecl:
	(global?='global')? name=ValidID OpAssignment variableValue=VariableParam
;

OpAssignment:
	'='
;

VariableParam returns VariableDecl:
	{VariableParam} 
	(variableStringParam=STRING | 
	 variableExpressionParam=Expression | 
	 variableQueryParam=Query |
	 variableBolleanValue=BooleanValue)
;

Query:
	'query' QueryParam
;

QueryParam returns Query:
	(queryValue=STRING | 
	 Expression)
;

Print:
	('print' | 'println') PrintParam
;

PrintParam returns Print:
	(printValue=STRING | 
	 Query | 
	 Expression)
;

FunctionCall:
	name=ValidID '('  
		(arguments+=(Expression | StringLiteral) 
		(',' arguments+=(Expression | StringLiteral))*)?
	 ')'
;

VariableCall:
	{VariableCall} variableCall=ValidID
;

Expression:
	Addition
;

Addition returns Expression:
	Substraction ({Addition.left=current} '+' right=Substraction)*
;

Substraction returns Expression:
	Multiplication ({Substraction.left=current} '-' right=Multiplication)*
;

Multiplication returns Expression:
	Division ({Multiplication.left=current} '*' right=Division)*
;
 
Division returns Expression:
	Mod ({Division.left=current} '/' right=Mod)*
;

Mod returns Expression:
	Primary ({Mod.left=current} '%' right=Primary)*
;

Primary returns Expression:
	(NumberLiteral | VariableCall | FunctionCall | ('(' Addition ')'))
;

CompoundStatement:
	IfStatement |
//	SwitchStatement |
	WhileStatement |
	ForStatement
;

FunctionDecl:
	'func' name=ValidID '(' (arguments+=ValidID (',' arguments+=ValidID)*)? ')' '{'
		(statements+=Statement)*
	'}'
;

IfStatement:
	{IfStatement}
	'if' '(' condition += StatementCondition ')' '{'
		(statements+=Statement)*
	'}'
	( 'else if' '(' condition+=StatementCondition ')' '{'
		(statements+=Statement)*
	'}'
	)*
	// doesn't work if there is no space after else (xtext bug probably)
	( 'else ' '{' 
		(statements+=Statement)*
	'}'
	)?
;

SwitchStatement:
	{SwitchStatement}
	'switch' '(' name=VariableCall ')' '{'
		('case' cases+=STRING ':'
			(statements+=Statement)*
		)*
		('default' ':'
			(statements+=Statement)*
		)?
	'}'
;

WhileStatement:
	{WhileStatement}
	'while' '(' whileCondition=StatementCondition ')' '{' 
		(statements+=Statement)* 
	'}'
;

ForStatement:
	{ForStatement}
	'for' '(' forVar=VariableDecl ';' 
		forCondition=StatementCondition ';' 
			operation=(PostfixOperation | ForMultiAssign | VariableDecl) ')' '{' 
			  	(statements+=Statement)* 
	'}'
;

StatementCondition:
	statementCondition+=Condition ((OpAnd | OpOr) statementCondition+=Condition)* 
;

Condition:
	 expressions+=ConditionElement (op+=OpCompare expressions+=ConditionElement)?
;

ConditionElement:
	(Expression | 
	 StringLiteral |
	 BooleanValue)
;

ForMultiAssign:
	left=VariableCall op=MultiAssignOperator right=INT
;

MultiAssign:
	left=VariableCall op=MultiAssignOperator right=MultiAssignRightOperand 
;

MultiAssignRightOperand:
	(VariableCall | 
	 StringLiteral | 
	 Query | 
	 NumberLiteral)
;

PostfixOperation:
		{PostfixOperation}	call=VariableCall op=PostfixOperationOperator
;

StringLiteral:
	value=STRING
;

NumberLiteral:
	value=NUMBER_LITERAL
;

terminal NUMBER_LITERAL:
	'0' | ('1'..'9') ('0'..'9')* ('.' ('0'..'9')*)?
;

BooleanValue:
	value=('true' | 
	'false')
;
MultiAssignOperator:
	('+=' | 
	'-=' | 
	'*=' | 
	'/=' | 
	'%=')
;
PostfixOperationOperator:
	('--' |
	'++')
;
OpAnd: '&&';
OpOr: '||';
OpCompare:
	('>' |
	'<' |
	'==' |
	'<=' |
	'>=' |
	'!=')
;
